" {{{1 DEFAULTS.VIM
" Use Vim settings, rather than Vi
set nocompatible

set backspace=indent,eol,start      " Allow backspacing over everything in insert mode

set history=1000	        " keep 1000 lines of command line history
set ruler                   " show the cursor position all the time
set showcmd	                " display incomplete commands
set wildmenu		        " display completion matches in a status line

set ttimeout		        " time out for key codes
set ttimeoutlen=50	        " wait up to 100ms after Esc for special key

set display+=lastline

set scrolloff=3             " show a few lines of context around the cursor
set sidescrolloff=5

set incsearch               " do incremental searching
set nrformats-=octal        " do not recognize octal numbers for Ctrl-A and Ctrl-X

" CTRL-U only deletes entered character and not always the whole line: fix that
" Use CTRL-G u to first break undo, so that you can undo CTRL-U after inserting a line break
inoremap <C-U> <C-G>u<C-\><C-O>d0

" Switch syntax highlighting on, when the terminal has colors
if &t_Co > 2 || has("gui_running")
    syntax enable
endif


if has("autocmd")
    " Enable file type detection.
    " Also load indent files, to automatically do language-dependent indenting.
    filetype plugin indent on

    augroup vimrcEx
        autocmd!

        " When editing a file, always jump to the last known cursor position.
        autocmd BufReadPost *
            \ if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit'
            \ |   exe "normal! g`\""
            \ | endif
    augroup END
endif

" Prevent that the langmap option applies to characters that result from a mapping
if has('langmap') && exists('+langnoremap')
    set langnoremap
endif


" {{{1 GENERAL OPTIONS

let mapleader = ","

set formatoptions+=j    " delete comment character when joining commented lines
set autoread

set shortmess+=I        " don't display message when running vim without file

" Replace patterns act on every occurence in line by default
" (and use g-flag to use default behavior)
set gdefault

set wildmode=longest:full,full   " when tabing, complete the longest, then disp list
set wildcharm=<C-z>              " autocompletion character in macros

set ignorecase
set smartcase           " case-sensitive search only when at least one capital letter

set path+=**            " set recursive path to use :find

set splitright          " new splits on the right...
set splitbelow          " ... and below

" Also set help by default in vertical split
cabbrev <expr> h ((getcmdtype() == ':' && getcmdpos() <= 2)? 'vert h' : 'h')
cabbrev <expr> help ((getcmdtype() == ':' && getcmdpos() <= 5)? 'vert help' : 'help')

set expandtab
set smarttab

set shiftwidth=4
set tabstop=4
set shiftround

set autoindent
set smartindent

set linebreak           " break line between words during wrap
set lazyredraw          " don't update screen during macros

set foldlevelstart=0

set notagrelative       " cf plugin/hidden_tags.vim

set viewoptions-=options        " To omit local options when restoring file (cf. mkview, loadview)
set sessionoptions-=options     " To restore syntax highlighting when restoring session (unzoom)

set bufhidden=delete    " To delete buffer instead of just unloading them

if has("autocmd")
    augroup dashKeyword
        autocmd!

        " Add - to word limit in text, markdown and bash files
        autocmd FileType text,markdown,sh,bib,tex setlocal iskeyword+=\-
    augroup END
endif

if has('mouse')
    set mouse=a
endif

set backup
set undofile

set backupdir=$HOME/.cache/vim/backup//,/tmp//    | call mkdir(&backupdir, 'p', 0700)
set directory=$HOME/.cache/vim/swap//,/tmp//      | call mkdir(&directory, 'p', 0700)
set viewdir=$HOME/.cache/vim/view                 | call mkdir(&viewdir, 'p', 0700)
set undodir=$HOME/.cache/vim/undo//,/tmp//        | call mkdir(&undodir, 'p', 0700)
set spellfile=$HOME/.cache/vim/spell/en.utf-8.add | call mkdir($HOME."/.cache/vim/spell", 'p', 0700)
let g:netrw_home=$HOME . "/.cache/vim/"

set viminfo+='1000,n$HOME/.cache/vim/viminfo

set dictionary+=/usr/share/dict/words

colorscheme molokai
filetype detect


" {{{1 ADDITIONAL PACKAGES

try
    packadd matchit
catch /.*/
endtry

" Auto-pairs
let g:AutoPairsShortcutToggle = ''
let g:AutoPairsShortcutJump = '<M-v>'
let g:AutoPairsShortcutBackInsert = '<M-c>'
let g:AutoPairsCenterLine = 0

" GitGutter
set updatetime=100
let g:gitgutter_enabled = 0
let g:gitgutter_highlight_lines = 1
let g:gitgutter_preview_win_floating = 1

nnoremap <silent> <leader>g :GitGutterToggle \| echo "GitGutter " . (g:gitgutter_enabled ? "enabled" : "disabled")<CR>
highlight GitGutterAdd    ctermfg=2
highlight GitGutterChange ctermfg=3
highlight GitGutterDelete ctermfg=1

highlight GitGutterStatuslineAdd    ctermfg=2 ctermbg=238
highlight GitGutterStatuslineChange ctermfg=3 ctermbg=238
highlight GitGutterStatuslineDelete ctermfg=1 ctermbg=238

highlight GitGutterStatuslineAddNC    cterm=bold ctermfg=2 ctermbg=244
highlight GitGutterStatuslineChangeNC cterm=bold ctermfg=3 ctermbg=244
highlight GitGutterStatuslineDeleteNC cterm=bold ctermfg=1 ctermbg=244


" Markdown
let g:vim_markdown_toc_autofit = 1
let g:vim_markdown_follow_anchor = 1
let g:vim_markdown_strikethrough = 1
let g:vim_markdown_new_list_item_indent = 2
let g:vim_markdown_folding_style_pythonic = 1

" Tagbar
let g:tagbar_position = 'topleft vertical'
let g:tagbar_sort = 0
let g:tagbar_autofocus = 1
let g:tagbar_autoclose = 1
let g:tagbar_jump_offset = 100
nnoremap <leader>c :TagbarOpen j<CR>

" Vim/Tmux navigator
let g:tmux_navigator_disable_when_zoomed = 1

" Zoom pane
let g:zoom#statustext = '[Z]'


" {{{1 USER MAPPINGS

" Edit and reload vim config
nnoremap <leader>e :call <SID>OpenInSplitIfNotEmpty($MYVIMRC)<CR>
nnoremap <leader>E :tabnew $MYVIMRC<CR>
nnoremap <leader>r :source $MYVIMRC \| redraw \| echo "Config reloaded !"<CR>

" Write file with <leader>w
nnoremap <leader>w :update <CR>

" Split
nnoremap <silent> <leader>\ :vsplit<CR>
nnoremap <silent> <leader><bar> :vsplit \| enew<CR>
nnoremap <silent> <leader>- :split<CR>
nnoremap <silent> <leader>_ :split \| enew<CR>
nnoremap <silent> <leader>= <C-w>=
nnoremap <silent> <leader>q :if get(t:, 'zoomed', 0) \| call zoom#toggle() \| endif \| quit<CR>

" Move splits around
nnoremap <leader>H <C-w>H
nnoremap <leader>J <C-w>J
nnoremap <leader>K <C-w>K
nnoremap <leader>L <C-w>L

" Tabs
nnoremap <silent> <leader>t :tab split<CR>
nnoremap <silent> <leader>T :tabnew<CR>
nnoremap <silent> <leader>n :tabnext<CR>
nnoremap <silent> <leader>p :tabprev<CR>
for i in range(1, 9)
    execute "nnoremap <silent> <leader>" . i . " :" . i . "tabnext<CR>"
endfor

nnoremap <leader>N :tabm <C-R>=(tabpagenr()+1)%(tabpagenr('$')+1)<CR><CR>
nnoremap <leader>P :tabm <C-R>=(tabpagenr()+tabpagenr('$')-1)%(tabpagenr('$')+1)<CR><CR>

nnoremap <leader>< <C-W>R
nnoremap <leader>> <C-W>r

" Send split to new tab
nnoremap <leader>! <C-W>T

" Scroll with C-[j|k]
nnoremap <C-j> <C-e>
vnoremap <C-j> <C-e>
nnoremap <C-k> <C-y>
vnoremap <C-k> <C-y>

" Exit insert mode with kj
inoremap kj <Esc>l
inoremap Kj <Esc>l
inoremap kJ <Esc>l
inoremap KJ <Esc>l

" Move line
nnoremap <silent> - :m .+1<CR>==
nnoremap <silent> _ :m .-2<CR>==
vnoremap <silent> - :m '>+1<CR>gv=gv
vnoremap <silent> _ :m '<-2<CR>gv=gv

" Add a new line
nnoremap <C-h> o<C-c>

" Operator pending mapping
onoremap in' :<C-u>normal! f'vi'<CR>
onoremap in" :<C-u>normal! f"vi"<CR>
onoremap in` :<C-u>normal! f`vi`<CR>
onoremap in( :<C-u>normal! f(vi(<CR>
onoremap in[ :<C-u>normal! f[vi[<CR>
onoremap in{ :<C-u>normal! f{vi{<CR>
onoremap in< :<C-u>normal! f<vi<<CR>

onoremap il' :<C-u>normal! F'hvi'<CR>
onoremap il" :<C-u>normal! F"hvi"<CR>
onoremap il` :<C-u>normal! F`hvi`<CR>
onoremap il( :<C-u>normal! F)vi(<CR>
onoremap il[ :<C-u>normal! F[vi[<CR>
onoremap il{ :<C-u>normal! F{vi{<CR>
onoremap il< :<C-u>normal! F<vi<<CR>

" Swap words
nnoremap <silent> gt "_yiw:s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<CR><C-o>/\w\+\_W\+<CR><C-l>:nohlsearch<CR>
nnoremap <silent> gT "_yiw?\w\+\_W\+<CR><C-l>:nohlsearch<CR>:s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<CR><C-o>

" Unmap Q and K
nnoremap Q <nop>
nnoremap K <nop>

" Y same as D or C
nnoremap Y y$

" Delete last word in command mode
cnoremap  <C-w>

" Shift-Tab to dedent
inoremap <S-Tab> <C-d>

" Enter opens folds in normal mode
nnoremap <silent><expr> <CR> getcmdwintype() !~ '[:/?]' ? ':silent! execute "normal! zO\n"<CR>' : '<CR>'

" Display current fold name
nnoremap <silent> z/ zc:echo foldtextresult(foldclosed('.'))<CR>zo

" Cancel autocomplete but reprint longest match
cmap <C-x> <C-l><C-n><C-p><C-u><C-y><C-z>

" Open autocomplete on next subdirectory
cnoremap <C-o> <Space><BS><C-z>

" Kill all windows except current
nnoremap <silent> <leader>o :only<CR>

" Redraw screen in insert mode
inoremap <C-l> <C-o><C-l>

" Correct last misspelled word
inoremap <silent> <C-k> <C-G>u<Esc>:call <SID>FixLineSpellError()<CR>`]a<C-G>u

" Quit visual mode with q
vnoremap q <C-c>


" {{{1 UTILITY FUNCTIONS / COMMANDS

" Function to open file in split if buffer not empty
function! s:OpenInSplitIfNotEmpty(file)
    if line('$') == 1 && getline(1) == ''
        exec 'e' a:file
    else
        exec 'vsplit' a:file
    end
endfunction

" Function to fix spelling error only on current line
function! s:FixLineSpellError()
    let l:lnum = line('.')
    normal! [s
    if l:lnum != line('.') | return | endif
    normal! 1z=
endfunction

function! s:DiffToggle()
    if &diff
        windo diffoff
        execute winnr() . 'wincmd w'
        return
    endif

    if tabpagewinnr('.', '$') != 2
        echohl ErrorMsg | echo "Can only diff two files" | echohl None
        return
    endif

    windo diffthis
    execute winnr() . 'wincmd w'
endfunction

" Command to diff if there are two splits on current window
if !exists(":DiffToggle")
    command -bar DiffToggle call <SID>DiffToggle()
endif

" Command to write read-only file
if !exists(":W")
    command W execute 'silent! write !sudo /usr/bin/tee "%" >/dev/null' <bar> edit!
endif


" {{{1 WHITESPACE HIGHLIGHTING

augroup whitespaceHighlight
    autocmd!

    highlight ExtraWhitespace ctermbg=red
    match ExtraWhitespace /\s\+$\| \+\ze\t/
    autocmd WinEnter * match ExtraWhitespace /\s\+$\| \+\ze\t/
    autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$\| \+\ze\t/
    autocmd InsertLeave * match ExtraWhitespace /\s\+$\| \+\ze\t/
    autocmd WinLeave * call clearmatches()

    autocmd InsertLeave * redraw!
augroup END

" {{{1 SAVE FOLDS

let g:skipview_files = []
function! MakeViewCheck()
    " Buffer is marked as not a file
    if &buftype =~ 'nofile' | return 0 | endif
    " Diff buffer
    if &diff | return 0 | endif
    " File does not exist on disk
    if empty(glob(expand('%:p'))) | return 0 | endif
    " File is in skip list
    if index(g:skipview_files, expand('%')) >= 0 | return 0 | endif
    return 1
endfunction

augroup vimrcAutoView
    autocmd!

    autocmd BufWritePost,WinLeave ?* if MakeViewCheck() | mkview | endif
    autocmd BufWinEnter ?* if MakeViewCheck() | silent loadview | endif
augroup END

" {{{1 TAB LINE

function! TabLine()
    let l:s = ''
    for l:tab in range(1, tabpagenr('$'))
        let l:winnr = tabpagewinnr(l:tab)
        let l:buflist = tabpagebuflist(l:tab)
        let l:bufnr = l:buflist[l:winnr - 1]
        let l:bufname = bufname(l:bufnr)
        let l:bufmodified = getbufvar(l:bufnr, "&mod")
        let l:base_color = (l:tab == tabpagenr() ? '%#TabLineSel#' : '%#TabLine#')
        let l:nb_color = (l:tab == tabpagenr() ? '%#TabLineNbSel#' : '%#TabLineNb#')

        let l:s .= '%' . l:tab . 'T' . l:base_color
        let l:s .= ' ' . l:nb_color . l:tab . l:base_color . " "
        let l:s .= (l:bufname != '' ? fnamemodify(l:bufname, ':t') : '[No Name]')

        let l:s .= (l:bufmodified ? ' [+]' : ' ')
    endfor

    let l:s .= '%#TabLineFill#'
    return l:s
endfunction

highlight TabLine cterm=underline ctermfg=15 ctermbg=242
highlight TabLineSel cterm=bold
highlight TabLineNbSel cterm=bold ctermfg=Brown
highlight TabLineNb cterm=underline ctermfg=Brown ctermbg=242
highlight TabLineFill ctermfg=Grey

set tabline=%!TabLine()


" {{{1 STATUS LINE

if !exists('g:statusline_git_branch')
    let g:statusline_git_branch = {}
    let g:is_tracked = {}
endif

augroup setStatusline
    autocmd!

    autocmd BufRead,BufEnter * call s:SetStatuslineGit()
    autocmd BufDelete * silent! unlet g:statusline_git_branch[expand("<abuf>")] |
                      \ silent! unlet g:is_tracked[expand("<abuf>")]
augroup END

function! s:SetStatuslineGit()
    let l:command = "git -C " . expand("%:h") . " rev-parse --abbrev-ref HEAD 2>/dev/null | tr -d '\n'"
    let l:git_branch = system(l:command)
    if !empty(l:git_branch) | let l:git_branch = ' ' . l:git_branch . ' ' | endif

    let g:statusline_git_branch[bufnr()] = l:git_branch
    let g:is_tracked[bufnr()] = !empty(expand("%:p")) && !empty(system("git ls-files " . expand("%:p")))
endfunction

function! MyStatusLine()
    let l:curr_winnr = winbufnr(g:statusline_winid)
    let l:git_branch = get(g:statusline_git_branch, l:curr_winnr, "")
    let l:is_tracked = get(g:is_tracked, l:curr_winnr, 0)

    let l:my_statusline  = ''
    if l:is_tracked | let l:my_statusline .= '%#PmenuSel#' . l:git_branch . '%0*' | endif
    let l:my_statusline .= ' %n ➤  %f%m'
    let l:my_statusline .= (get(b:, 'todo_mode', 0) ? '[T]' : '')
    let l:my_statusline .= '%{zoom#statusline()}'

    " Git gutter
    if g:gitgutter_enabled && !empty(l:git_branch) && l:is_tracked
        let [a, m, r] = gitgutter#hunk#summary(l:curr_winnr)
        let l:inactive = l:curr_winnr != winnr() ? "NC" : ""
        let l:my_statusline .= ' ['
        let l:my_statusline .= '%#GitGutterStatuslineAdd' . l:inactive . '#+' . a . ' '
        let l:my_statusline .= '%#GitGutterStatuslineChange' . l:inactive . '#~' . m . ' '
        let l:my_statusline .= '%#GitGutterStatuslineDelete' . l:inactive . '#-' . r . '%0*'
        let l:my_statusline .= '] '
    endif

    let l:my_statusline .= '%='
    let l:my_statusline .= '%y %#PmenuSel# %3l/%L %3c| '
    return l:my_statusline
endfunction

set laststatus=2
set statusline=%!MyStatusLine()


" {{{1 FIXES

" Fix Ctrl-Arrow
noremap [1;5D <C-Left>
noremap! [1;5D <C-Left>
noremap [1;5C <C-Right>
noremap! [1;5C <C-Right>

" Fix Alt shortcuts <M-key>
let c='a'
while c <= 'z'
    exec "set <M-".c.">=\e".c
    exec "imap \e".c." <M-".c.">"
    let c = nr2char(1+char2nr(c))
endw

" Toggle paste mode each time pasting from clipboard, and remove it after
" Source : https://coderwall.com/p/if9mda/automatically-set-paste-mode-in-vim-when-pasting-in-insert-mode
let &t_SI .= "\<Esc>[?2004h"
let &t_EI .= "\<Esc>[?2004l"

inoremap <special> <expr> <Esc>[200~ XTermPasteBegin()

function! XTermPasteBegin()
    set pastetoggle=<Esc>[201~
    set paste
    return ""
endfunction

" vim:fdm=marker
