" {{{1 DEFAULTS.VIM
" Use Vim settings, rather than Vi
set nocompatible

set backspace=indent,eol,start      " Allow backspacing over everything in insert mode

set history=1000	        " keep 1000 lines of command line history
set ruler                   " show the cursor position all the time
set showcmd	                " display incomplete commands
set wildmenu		        " display completion matches in a status line

set ttimeout		        " time out for key codes
set ttimeoutlen=50	        " wait up to 100ms after Esc for special key

set display+=lastline

set scrolloff=3             " show a few lines of context around the cursor
set sidescrolloff=5

set incsearch               " do incremental searching
set nrformats-=octal        " do not recognize octal numbers for Ctrl-A and Ctrl-X

" CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
" so that you can undo CTRL-U after inserting a line break.
inoremap <C-U> <C-G>u<C-U>

" Switch syntax highlighting on, when the terminal has colors
if &t_Co > 2 || has("gui_running")
    syntax enable
endif


if has("autocmd")
    " Enable file type detection.
    " Also load indent files, to automatically do language-dependent indenting.
    filetype plugin indent on

    augroup vimrcEx
        autocmd!

        " When editing a file, always jump to the last known cursor position.
        autocmd BufReadPost *
            \ if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit'
            \ |   exe "normal! g`\""
            \ | endif
    augroup END
endif

" Prevent that the langmap option applies to characters that result from a mapping
if has('langmap') && exists('+langnoremap')
    set langnoremap
endif


" {{{1 GENERAL OPTIONS

let mapleader = ","

set formatoptions+=j    " delete comment character when joining commented lines
set autoread

set shortmess+=I        " don't display message when running vim without file

" Replace patterns act on every occurence in line by default
" (and use g-flag to use default behavior)
set gdefault

set wildmode=longest:full,full   " when tabing, complete the longest, then disp list
set wildcharm=<C-z>              " autocompletion character in macros

set ignorecase
set smartcase           " case-sensitive search only when at least one capital letter

set path+=**            " set recursive path to use :find

set splitright          " new splits on the right...
set splitbelow          " ... and below

" Also set help by default in vertical split
cabbrev <expr> h ((getcmdtype() == ':' && getcmdpos() <= 2)? 'vert h' : 'h')
cabbrev <expr> help ((getcmdtype() == ':' && getcmdpos() <= 5)? 'vert help' : 'help')

set expandtab
set smarttab

set shiftwidth=4
set tabstop=4
set shiftround

set autoindent
set smartindent

set linebreak           " break line between words during wrap
set lazyredraw          " don't update screen during macros

set foldlevelstart=0

set notagrelative       " cf plugin/hidden_tags.vim

set sessionoptions-=options     " To restore syntax highlighting when restoring session (unzoom)

if has("autocmd")
    augroup myGroup
        autocmd!

        " Add - to word limit in text, markdown and bash files
        autocmd FileType text,markdown,sh setlocal iskeyword+=\-
    augroup END
endif

if has('mouse')
    set mouse=a
endif

set backup
set undofile

set backupdir=$HOME/.cache/vim/backup//,/tmp// | call mkdir(&backupdir, 'p', 0700)
set directory=$HOME/.cache/vim/swap//,/tmp//   | call mkdir(&directory, 'p', 0700)
set viewdir=$HOME/.cache/vim/view              | call mkdir(&viewdir, 'p', 0700)
set undodir=$HOME/.cache/vim/undo//,/tmp//     | call mkdir(&undodir, 'p', 0700)

set viminfo+='1000,n$HOME/.cache/vim/viminfo

set dictionary+=/usr/share/dict/words

colorscheme molokai
filetype detect


" {{{1 ADDITIONAL PACKAGES

try
    packadd matchit
catch /.*/
endtry

" Auto-pairs
let g:AutoPairsShortcutToggle = ''
let g:AutoPairsShortcutJump = ''
let g:AutoPairsShortcutBackInsert = '<M-c>'
let g:AutoPairsCenterLine = 0

" Markdown
let g:vim_markdown_toc_autofit = 1
let g:vim_markdown_follow_anchor = 1
let g:vim_markdown_strikethrough = 1
let g:vim_markdown_new_list_item_indent = 2

" Tagbar
let g:tagbar_position = 'topleft vertical'
let g:tagbar_sort = 0
let g:tagbar_autofocus = 1
let g:tagbar_jump_offset = 100
nnoremap <leader>c :TagbarOpen j<CR>

" Vim/Tmux navigator
let g:tmux_navigator_disable_when_zoomed = 1

" Zoom pane
let g:zoom#statustext = '[Z]'


" {{{1 USER MAPPINGS

" Edit and reload vim config
nnoremap <leader>e :call OpenInSplitIfNotEmpty($MYVIMRC)<CR>
nnoremap <leader>E :tabnew $MYVIMRC<CR>
nnoremap <leader>r :source $MYVIMRC \| redraw \| echo "Config reloaded !"<CR>

" Write file with <leader>w
nnoremap <leader>w :update <CR>

" Split
nnoremap <silent> <leader>\ :vsplit<CR>
nnoremap <silent> <leader><bar> :vsplit \| enew<CR>
nnoremap <silent> <leader>- :split<CR>
nnoremap <silent> <leader>_ :split \| enew<CR>
nnoremap <silent> <leader>= <C-w>=
nnoremap <silent> <leader>q :q<CR>

" Move splits around
nnoremap <leader>H <C-w>H
nnoremap <leader>J <C-w>J
nnoremap <leader>K <C-w>K
nnoremap <leader>L <C-w>L

" Tabs
nnoremap <silent> <leader>t :tab split<CR>
nnoremap <silent> <leader>T :tabnew<CR>
nnoremap <silent> <leader>n :tabnext<CR>
nnoremap <silent> <leader>p :tabprev<CR>
for i in range(1, 9)
    execute "nnoremap <silent> <leader>" . i . " :" . i . "tabnext<CR>"
endfor

nnoremap <leader>N :tabm <C-R>=(tabpagenr()+1)%(tabpagenr('$')+1)<CR><CR>
nnoremap <leader>P :tabm <C-R>=(tabpagenr()+tabpagenr('$')-1)%(tabpagenr('$')+1)<CR><CR>

nnoremap <leader>< <C-W>R
nnoremap <leader>> <C-W>r

" Send split to new tab
nnoremap <leader>! <C-W>T

" Scroll with C-[j|k]
nnoremap <C-j> <C-e>
vnoremap <C-j> <C-e>
nnoremap <C-k> <C-y>
vnoremap <C-k> <C-y>

" Exit insert mode with kj
inoremap kj <Esc>l
inoremap Kj <Esc>l
inoremap kJ <Esc>l
inoremap KJ <Esc>l

" Move line
nnoremap <silent> - :m .+1<CR>==
nnoremap <silent> _ :m .-2<CR>==
vnoremap <silent> - :m '>+1<CR>gv=gv
vnoremap <silent> _ :m '<-2<CR>gv=gv

" Add a new line
nnoremap <C-h> o<C-c>

" Operator pending mapping
onoremap in' :<C-u>normal! f'vi'<CR>
onoremap in" :<C-u>normal! f"vi"<CR>
onoremap in` :<C-u>normal! f`vi`<CR>
onoremap in( :<C-u>normal! f(vi(<CR>
onoremap in[ :<C-u>normal! f[vi[<CR>
onoremap in{ :<C-u>normal! f{vi{<CR>
onoremap in< :<C-u>normal! f<vi<<CR>

onoremap il' :<C-u>normal! F'hvi'<CR>
onoremap il" :<C-u>normal! F"hvi"<CR>
onoremap il` :<C-u>normal! F`hvi`<CR>
onoremap il( :<C-u>normal! F)vi(<CR>
onoremap il[ :<C-u>normal! F[vi[<CR>
onoremap il{ :<C-u>normal! F{vi{<CR>
onoremap il< :<C-u>normal! F<vi<<CR>

" Swap words
nnoremap <silent> gt "_yiw:s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<CR><C-o>/\w\+\_W\+<CR><C-l>:nohlsearch<CR>
nnoremap <silent> gT "_yiw?\w\+\_W\+<CR><C-l>:nohlsearch<CR>:s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<CR><C-o>

" Unmap Q and K
nnoremap Q <nop>
nnoremap K <nop>

" Y same as D or C
nnoremap Y y$

" Delete last word in command mode
cnoremap  <C-w>

" Shift-Tab to dedent
inoremap <S-Tab> <C-d>

" Enter opens folds in normal mode
nnoremap <silent><expr> <CR> getcmdwintype() !~ '[/?]' ? ':silent! execute "normal! zO\n"<CR>' : '<CR>'

" Cancel autocomplete but reprint longest match
cmap <C-x> <C-l><C-n><C-p><C-u><C-y><C-z>

" Open autocomplete on next subdirectory
cnoremap <C-o> <Space><BS><C-z>

" Kill all windows except current
nnoremap <silent> <leader>o :only<CR>

" Redraw screen in insert mode
inoremap <C-l> <C-o><C-l>

" Correct last misspelled word
inoremap <C-k> <C-G>u<Esc>[s1z=`]a<C-G>u

" Quit visual mode with q
vnoremap q <C-c>


" {{{1 COMMANDS

" Function to open file in split if buffer not empty
function! OpenInSplitIfNotEmpty(file)
    if line('$') == 1 && getline(1) == ''
        exec 'e' a:file
    else
        exec 'vsplit' a:file
    end
endfunction

" Command to write read-only file
if !exists(":W")
    command W execute 'silent! write !sudo /usr/bin/tee "%" >/dev/null' <bar> edit!
endif

" Command to diff if there are two splits on current window
function! DiffToggle()
    if &diff
        windo diffoff
        execute winnr() . 'wincmd w'
        return
    endif

    if tabpagewinnr('.', '$') != 2
        echohl ErrorMsg | echo "Can only diff two files" | echohl None
        return
    endif

    windo diffthis
    execute winnr() . 'wincmd w'
endfunction
if !exists(":DiffToggle")
    command DiffToggle call DiffToggle()
endif


" {{{1 WHITESPACE HIGHLIGHTING

augroup whitespaceHighlight
    autocmd!

    highlight ExtraWhitespace ctermbg=red
    match ExtraWhitespace /\s\+$\| \+\ze\t/
    autocmd WinEnter * match ExtraWhitespace /\s\+$\| \+\ze\t/
    autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$\| \+\ze\t/
    autocmd InsertLeave * match ExtraWhitespace /\s\+$\| \+\ze\t/
    autocmd WinLeave * call clearmatches()

    autocmd InsertLeave * redraw!
augroup END

" {{{1 SAVE FOLDS

let g:skipview_files = []
function! MakeViewCheck()
    " Buffer is marked as not a file
    if &buftype =~ 'nofile' | return 0 | endif
    " Diff buffer
    if &diff | return 0 | endif
    " File does not exist on disk
    if empty(glob(expand('%:p'))) | return 0 | endif
    " File is in skip list
    if index(g:skipview_files, expand('%')) >= 0 | return 0 | endif
    return 1
endfunction
augroup vimrcAutoView
    autocmd!

    autocmd BufWritePost,BufLeave,WinLeave ?* if MakeViewCheck() | mkview | endif
    autocmd BufWinEnter ?* if MakeViewCheck() | silent loadview | endif
augroup END

" {{{1 TAB LINE

function! TabLine()
    let l:s = ''
    for l:tab in range(1, tabpagenr('$'))
        let l:winnr = tabpagewinnr(l:tab)
        let l:buflist = tabpagebuflist(l:tab)
        let l:bufnr = l:buflist[l:winnr - 1]
        let l:bufname = bufname(l:bufnr)
        let l:bufmodified = getbufvar(l:bufnr, "&mod")
        let l:base_color = (l:tab == tabpagenr() ? '%#TabLineSel#' : '%#TabLine#')
        let l:nb_color = (l:tab == tabpagenr() ? '%#TabLineNbSel#' : '%#TabLineNb#')

        let l:s .= '%' . l:tab . 'T' . l:base_color
        let l:s .= ' ' . l:nb_color . l:tab . l:base_color . " "
        let l:s .= (l:bufname != '' ? fnamemodify(l:bufname, ':t') : '[No Name]')

        let l:s .= (l:bufmodified ? ' [+]' : ' ')
    endfor

    let l:s .= '%#TabLineFill#'
    return l:s
endfunction

highlight TabLine cterm=underline ctermfg=15 ctermbg=242
highlight TabLineSel cterm=bold
highlight TabLineNbSel cterm=bold ctermfg=Brown
highlight TabLineNb cterm=underline ctermfg=Brown ctermbg=242
highlight TabLineFill ctermfg=Grey

set tabline=%!TabLine()


" {{{1 STATUS LINE

function! StatuslineGit()
    let l:branchname = system("git rev-parse --abbrev-ref HEAD 2>/dev/null | tr -d '\n'")
    return !empty(l:branchname) ? '  ' . l:branchname . ' ' : ''
endfunction

set laststatus=2
set statusline=
set statusline+=%#PmenuSel#
set statusline+=%{StatuslineGit()}
set statusline+=%#LineNr#
set statusline+=%0*
set statusline+=\ %f
set statusline+=%m
set statusline+=%{zoom#statusline()}
set statusline+=%=
set statusline+=\ %l/%L
set statusline+=\ (%p%%)


" {{{1 FIXES

" Fix Ctrl-Arrow
noremap [1;5D <C-Left>
noremap! [1;5D <C-Left>
noremap [1;5C <C-Right>
noremap! [1;5C <C-Right>

" Fix Alt shortcuts <M-key>
let c='a'
while c <= 'z'
    exec "set <M-".c.">=\e".c
    exec "imap \e".c." <M-".c.">"
    let c = nr2char(1+char2nr(c))
endw

" Toggle paste mode each time pasting from clipboard, and remove it after
" Source : https://coderwall.com/p/if9mda/automatically-set-paste-mode-in-vim-when-pasting-in-insert-mode
let &t_SI .= "\<Esc>[?2004h"
let &t_EI .= "\<Esc>[?2004l"

inoremap <special> <expr> <Esc>[200~ XTermPasteBegin()

function! XTermPasteBegin()
    set pastetoggle=<Esc>[201~
    set paste
    return ""
endfunction

" vim:fdm=marker
